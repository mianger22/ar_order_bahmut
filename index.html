<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Модели по дуге с управлением</title>
  <!-- Аксессуары: A-Frame, AR.js -->
    <script src="ar_libraries/aframe-master/dist/aframe-v1.6.0.min.js"></script>
    <script src="ar_libraries/AR.js-3.4.0/aframe/build/aframe-ar.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false;"
  >
    <!-- Модели на дуге -->
    <a-entity id="model1" geometry="primitive: box" material="color: red" position="0 0 -3" rotation="0 0 0"></a-entity>
    <a-entity id="model2" geometry="primitive: box" material="color: green" position="0 0 -3" rotation="0 0 0"></a-entity>
    <a-entity id="model3" geometry="primitive: box" material="color: blue" position="0 0 -3" rotation="0 0 0"></a-entity>

    <a-camera id="camera" position="0 0 0" cursor="raycaster" raycaster="objects: .clickable"></a-camera>
  </a-scene>

  <script>
    const models = [
      document.querySelector('#model1'),
      document.querySelector('#model2'),
      document.querySelector('#model3')
    ];

    // Расположение по дуге
    const radius = 2;
    const angleStart = -Math.PI / 4; // -45°
    const angleEnd = Math.PI / 4;    // +45°
    const angleStep = (angleEnd - angleStart) / (models.length - 1);

    models.forEach((model, index) => {
      const angle = angleStart + index * angleStep;
      model.setAttribute('position', {
        x: radius * Math.sin(angle),
        y: 0,
        z: -radius * Math.cos(angle)
      });
      model.classList.add('clickable'); // чтобы raycaster их заметил
    });

    let selectedModel = null;
    let isDragging = false;

    // Вспомогательные переменные
    let previousX = 0;

    // Функция, которая получает позицию мыши или касания
    function getPointerEvent(evt) {
      if (evt.touches && evt.touches.length > 0) {
        return { x: evt.touches[0].clientX, y: evt.touches[0].clientY };
      } else {
        return { x: evt.clientX, y: evt.clientY };
      }
    }

    // Обработчик клика или касания для выбора модели
    document.querySelector('a-scene').addEventListener('click', function(evt) {
      const pointer = getPointerEvent(evt);
      pickModel(pointer.x, pointer.y);
    });

    // Для касаний
    document.querySelector('a-scene').addEventListener('touchstart', function(evt) {
      const pointer = getPointerEvent(evt);
      pickModel(pointer.x, pointer.y);
    });

    function pickModel(clientX, clientY) {
      const sceneEl = document.querySelector('a-scene');
      const cameraEl = document.querySelector('#camera');

      // Создаем raycaster
      const raycaster = new THREE.Raycaster();

      // Получаем размеры рендеринга
      const rect = sceneEl.canvas.getBoundingClientRect();

      // Calculируем нормализованные координаты устройства
      const normX = ((clientX - rect.left) / rect.width) * 2 - 1;
      const normY = -((clientY - rect.top) / rect.height) * 2 + 1;

      // Обновляем луч
      raycaster.setFromCamera({ x: normX, y: normY }, cameraEl.object3D);

      // Проверяем пересечения
      const intersects = raycaster.intersectObjects(
        models.map(m => m.object3D),
        true
      );

      if (intersects.length > 0) {
        selectedModel = intersects[0].object.el; // выбранная модель
        // Можно начать перетягивание
        isDragging = true;
        // Запоминаем начальный X
        previousX = normX;
      }
    }

    // Обработчики движения мыши или касания
    document.querySelector('a-scene').addEventListener('mousemove', function(evt) {
      if (isDragging && selectedModel) {
        handleDrag(evt);
      }
    });
    document.querySelector('a-scene').addEventListener('touchmove', function(evt) {
      if (isDragging && selectedModel) {
        handleDrag(evt);
      }
    });

    function handleDrag(evt) {
      const pointer = getPointerEvent(evt);
      const sceneEl = document.querySelector('a-scene');
      const cameraEl = document.querySelector('#camera');
      const rect = sceneEl.canvas.getBoundingClientRect();

      const normX = ((pointer.x - rect.left) / rect.width) * 2 - 1;
      const deltaX = normX - previousX;
      previousX = normX;

      // Вращение модели по Y
      const rotationSpeed = 2; // настройка
      const currentRotationY = selectedModel.getAttribute('rotation').y || 0;
      selectedModel.setAttribute('rotation', {
        x: selectedModel.getAttribute('rotation').x,
        y: currentRotationY + deltaX * rotationSpeed
      });

      // Перемещение по дуге: изменение угла по X
      const currentPos = selectedModel.object3D.position;
      const currentAngle = Math.atan2(currentPos.x, -currentPos.z);
      const deltaAngle = deltaX * 0.5; // регулируйте чувствительность
      const newAngle = currentAngle + deltaAngle;

      // Обновляем позицию по дуге
      selectedModel.object3D.position.x = radius * Math.sin(newAngle);
      selectedModel.object3D.position.z = -radius * Math.cos(newAngle);
    }

    // Конец перетаскивания
    document.querySelector('a-scene').addEventListener('mouseup', function() {
      isDragging = false;
      selectedModel = null;
    });
    document.querySelector('a-scene').addEventListener('touchend', function() {
      isDragging = false;
      selectedModel = null;
    });
  </script>
</body>
</html>